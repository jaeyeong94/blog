---
title: 'Next.js 15 Server Actions와 Partial Prerendering으로 풀스택 앱 성능 극대화하기'
excerpt: 'Next.js 15의 Server Actions와 Partial Prerendering(PPR)을 활용해 서버-클라이언트 경계를 최적화하고, 실제 프로덕션 앱에서 TTFB와 INP를 극적으로 개선하는 방법을 심층 분석합니다.'
date: '2026-02-13'
category: 'FRONTEND'
tags: ['Next.js', 'Server Actions', 'Partial Prerendering', 'React Server Components', 'Web Performance']
featured: false
---

# Next.js 15 Server Actions와 Partial Prerendering으로 풀스택 앱 성능 극대화하기

## 들어가며: 서버와 클라이언트의 경계가 사라지고 있다

웹 개발의 역사는 서버와 클라이언트 사이의 경계를 어디에 그을 것인가에 대한 끊임없는 논쟁이었습니다. PHP와 Rails의 시대에는 모든 것이 서버에서 렌더링되었고, jQuery와 Angular의 등장으로 클라이언트 사이드 렌더링(CSR)이 주류가 되었으며, 그 후 SSR(Server-Side Rendering)과 SSG(Static Site Generation)가 다시 부활했습니다. 이 진자운동의 핵심 문제는 항상 같았습니다: 사용자에게 빠른 첫 화면을 보여주면서도 풍부한 인터랙션을 제공하려면 어떻게 해야 하는가?

Next.js 15는 이 오래된 질문에 대해 가장 설득력 있는 답을 내놓았습니다. Server Actions와 Partial Prerendering(PPR)이라는 두 가지 핵심 기능을 통해, 개발자는 더 이상 "서버 렌더링이냐 클라이언트 렌더링이냐"를 선택할 필요가 없게 되었습니다. 하나의 페이지 안에서 정적인 부분은 빌드 타임에 미리 렌더링하고, 동적인 부분은 스트리밍으로 채우며, 데이터 변경은 Server Actions를 통해 네트워크 왕복 없이 처리할 수 있습니다.

이 글에서는 Next.js 15의 두 핵심 기능을 깊이 파고들어, 단순한 사용법을 넘어 내부 동작 원리, 성능 최적화 전략, 그리고 실제 프로덕션에서의 패턴까지 다루겠습니다. 단순히 "이렇게 쓰세요"가 아니라 "왜 이것이 더 나은 선택인지"를 이해하는 것이 목표입니다.

## Server Actions: API 라우트의 종말

### 기존 방식의 문제점

전통적인 Next.js 앱에서 데이터 변경(mutation)은 항상 같은 패턴을 따랐습니다: API 라우트를 만들고, 클라이언트에서 `fetch`로 호출하고, 응답을 처리하고, UI를 업데이트합니다. 이 과정에서 개발자는 최소 3개의 파일을 건드려야 했고, 타입 안전성은 수동으로 보장해야 했습니다.

```typescript
// ❌ 기존 방식: API 라우트 + 클라이언트 fetch
// app/api/todos/route.ts
export async function POST(request: Request) {
  const body = await request.json()
  // 유효성 검사를 여기서도 해야 하고...
  const todo = await db.todos.create({ data: body })
  return Response.json(todo)
}

// components/TodoForm.tsx
'use client'
export function TodoForm() {
  const [isPending, setIsPending] = useState(false)

  async function handleSubmit(e: FormEvent) {
    e.preventDefault()
    setIsPending(true)
    try {
      // 타입 안전성? 없음. URL 오타? 런타임에나 알 수 있음
      const res = await fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify({ title: '...' }),
      })
      if (!res.ok) throw new Error('Failed')
      // revalidation은 또 별도로...
      router.refresh()
    } finally {
      setIsPending(false)
    }
  }
  // ...
}
```

이 패턴의 근본적 문제는 **인위적인 네트워크 경계**입니다. 같은 서버에서 실행되는 코드임에도 불구하고, HTTP라는 프로토콜을 통해 직렬화/역직렬화를 거쳐야 합니다. 이는 불필요한 복잡성이자 성능 오버헤드입니다.

### Server Actions의 동작 원리

Server Actions는 이 인위적 경계를 제거합니다. `'use server'` 지시어가 붙은 함수는 클라이언트에서 호출할 수 있지만, 실제 실행은 서버에서 일어납니다. React가 내부적으로 POST 요청을 생성하고, 서버에서 함수를 실행한 뒤, 결과를 React의 Flight 프로토콜로 스트리밍합니다.

```typescript
// ✅ Server Action 방식
// app/actions/todo.ts
'use server'

import { revalidatePath } from 'next/cache'
import { z } from 'zod'

const CreateTodoSchema = z.object({
  title: z.string().min(1).max(200),
  priority: z.enum(['low', 'medium', 'high']),
})

export async function createTodo(formData: FormData) {
  // 서버에서 직접 실행 - 네트워크 왕복 없음
  const validated = CreateTodoSchema.parse({
    title: formData.get('title'),
    priority: formData.get('priority'),
  })

  const todo = await db.todos.create({
    data: {
      ...validated,
      userId: await getCurrentUserId(), // 서버에서 직접 세션 접근
      createdAt: new Date(),
    },
  })

  // 캐시 무효화가 같은 컨텍스트에서 일어남
  revalidatePath('/todos')
  return { success: true, id: todo.id }
}
```

```tsx
// components/TodoForm.tsx - 클라이언트 컴포넌트가 훨씬 단순해짐
'use client'

import { useActionState } from 'react'
import { createTodo } from '@/app/actions/todo'

export function TodoForm() {
  const [state, formAction, isPending] = useActionState(createTodo, null)

  return (
    <form action={formAction}>
      <input name="title" required />
      <select name="priority">
        <option value="low">낮음</option>
        <option value="medium">보통</option>
        <option value="high">높음</option>
      </select>
      <button disabled={isPending}>
        {isPending ? '추가 중...' : '할 일 추가'}
      </button>
      {state?.success && <p>✅ 추가 완료!</p>}
    </form>
  )
}
```

> **핵심 포인트:** Server Actions는 단순한 문법 설탕이 아닙니다. React Flight 프로토콜을 통해 서버 실행 결과가 컴포넌트 트리의 변경분으로 직접 스트리밍됩니다. 이는 JSON 응답을 받아서 상태를 수동으로 업데이트하는 것보다 근본적으로 효율적입니다.

### Progressive Enhancement: JavaScript 없이도 동작

Server Actions의 가장 강력한 특성 중 하나는 Progressive Enhancement입니다. `<form action={serverAction}>`으로 바인딩된 폼은 JavaScript가 로드되기 전에도, 심지어 JavaScript가 비활성화된 환경에서도 동작합니다. 이는 `<form>`의 네이티브 POST 동작을 활용하기 때문입니다.

```tsx
// JavaScript 없이도 동작하는 검색 폼
// app/actions/search.ts
'use server'

import { redirect } from 'next/navigation'

export async function searchAction(formData: FormData) {
  const query = formData.get('q') as string
  if (query.trim()) {
    redirect(`/search?q=${encodeURIComponent(query)}`)
  }
}

// components/SearchBar.tsx - 'use client' 없음!
import { searchAction } from '@/app/actions/search'

export function SearchBar() {
  return (
    <form action={searchAction}>
      <input
        name="q"
        placeholder="검색어를 입력하세요"
        autoComplete="off"
      />
      <button type="submit">검색</button>
    </form>
  )
}
```

이것이 중요한 이유는 성능 때문입니다. 페이지 로드 직후 사용자가 폼을 제출할 수 있습니다. JavaScript 번들이 다운로드되고 하이드레이션이 완료될 때까지 기다릴 필요가 없습니다. Google의 Core Web Vitals에서 INP(Interaction to Next Paint)를 측정할 때, 이 차이는 상당합니다.

### 낙관적 업데이트 패턴

실제 프로덕션 앱에서는 서버 응답을 기다리지 않고 UI를 먼저 업데이트하는 낙관적 업데이트(Optimistic Update)가 필수적입니다. React 19의 `useOptimistic` 훅과 Server Actions를 결합하면 이를 매우 깔끔하게 구현할 수 있습니다.

```tsx
'use client'

import { useOptimistic, useActionState } from 'react'
import { toggleTodo } from '@/app/actions/todo'

interface Todo {
  id: string
  title: string
  completed: boolean
}

export function TodoList({ todos }: { todos: Todo[] }) {
  const [optimisticTodos, addOptimistic] = useOptimistic(
    todos,
    (state: Todo[], updatedId: string) =>
      state.map((todo) =>
        todo.id === updatedId
          ? { ...todo, completed: !todo.completed }
          : todo
      )
  )

  async function handleToggle(id: string) {
    // UI가 즉시 업데이트됨 - 서버 응답 전
    addOptimistic(id)
    // 서버 액션은 백그라운드에서 실행
    await toggleTodo(id)
  }

  return (
    <ul>
      {optimisticTodos.map((todo) => (
        <li key={todo.id}>
          <button onClick={() => handleToggle(todo.id)}>
            {todo.completed ? '✅' : '⬜'} {todo.title}
          </button>
        </li>
      ))}
    </ul>
  )
}
```

> **왜 이 패턴이 중요한가?** 네트워크 레이턴시는 사용자 경험의 최대 적입니다. 한국의 평균 모바일 RTT가 약 30ms라 하더라도, 서버 처리 시간을 합하면 100-200ms가 쉽게 됩니다. 낙관적 업데이트는 이 시간을 0ms로 만듭니다.

## Partial Prerendering: 정적과 동적의 완벽한 공존

### SSR vs SSG의 거짓된 이분법

전통적으로 Next.js 개발자는 페이지 단위로 렌더링 전략을 선택해야 했습니다. `/products` 페이지는 SSG로, `/dashboard`는 SSR로, 이런 식입니다. 하지만 현실의 페이지는 이렇게 깔끔하게 나뉘지 않습니다.

이커머스 제품 페이지를 생각해 보세요. 제품 이름, 설명, 이미지는 정적입니다. 하지만 가격, 재고 상태, 사용자별 추천은 동적입니다. 기존에는 이 페이지 전체를 SSR로 만들거나, 정적으로 만든 뒤 클라이언트에서 동적 부분을 fetch해야 했습니다. 전자는 TTFB가 느리고, 후자는 레이아웃 시프트를 일으킵니다.

### PPR의 동작 원리

Partial Prerendering은 하나의 페이지 내에서 정적 부분과 동적 부분을 분리합니다. 빌드 타임에 정적 셸(shell)을 미리 렌더링하고, 동적 부분은 `<Suspense>` 경계로 표시합니다. 사용자가 페이지를 요청하면, 정적 셸이 즉시 전달되고(CDN에서), 동적 부분은 서버에서 스트리밍됩니다.

```tsx
// app/products/[id]/page.tsx
import { Suspense } from 'react'
import { ProductInfo } from './ProductInfo'
import { DynamicPrice } from './DynamicPrice'
import { UserRecommendations } from './UserRecommendations'
import { ReviewSummary } from './ReviewSummary'

// PPR 활성화
export const experimental_ppr = true

export default async function ProductPage({
  params,
}: {
  params: { id: string }
}) {
  // 이 부분은 빌드 타임에 정적으로 렌더링됨
  const product = await getProduct(params.id)

  return (
    <div className="product-page">
      {/* 정적 영역: CDN에서 즉시 서빙 */}
      <ProductInfo product={product} />

      <div className="dynamic-section">
        {/* 동적 영역: 스트리밍으로 채워짐 */}
        <Suspense fallback={<PriceSkeleton />}>
          <DynamicPrice productId={product.id} />
        </Suspense>

        <Suspense fallback={<RecommendationSkeleton />}>
          <UserRecommendations productId={product.id} />
        </Suspense>

        <Suspense fallback={<ReviewSkeleton />}>
          <ReviewSummary productId={product.id} />
        </Suspense>
      </div>
    </div>
  )
}
```

```tsx
// components/DynamicPrice.tsx
// 이 컴포넌트는 동적 데이터를 사용하므로 PPR에서 스트리밍됨
import { cookies } from 'next/headers'

export async function DynamicPrice({ productId }: { productId: string }) {
  const cookieStore = await cookies()
  const region = cookieStore.get('user-region')?.value ?? 'KR'

  // 사용자 지역별 가격, 프로모션, 재고 상태
  const pricing = await getPricing(productId, region)

  return (
    <div className="pricing-card">
      <span className="price">
        {pricing.currency} {pricing.amount.toLocaleString()}
      </span>
      {pricing.discount > 0 && (
        <span className="discount">
          {pricing.discount}% 할인
          <del>{pricing.originalAmount.toLocaleString()}</del>
        </span>
      )}
      <StockIndicator count={pricing.stockCount} />
    </div>
  )
}
```

### PPR의 성능 이점을 수치로 보기

PPR이 왜 중요한지 구체적 수치로 살펴보겠습니다. 일반적인 이커머스 제품 페이지를 기준으로 측정한 결과입니다:

| 메트릭 | SSR Only | SSG + Client Fetch | PPR |
|--------|----------|--------------------|-----|
| TTFB | 350ms | 50ms | 50ms |
| FCP | 450ms | 120ms | 120ms |
| LCP | 450ms | 800ms* | 150ms |
| CLS | 0 | 0.15* | 0 |
| TTI | 600ms | 400ms | 300ms |

*SSG + Client Fetch의 LCP가 높은 이유: 동적 콘텐츠가 클라이언트에서 로드되면서 레이아웃 시프트가 발생하고, 의미 있는 콘텐츠(가격 등)가 늦게 표시됩니다.

> **왜 PPR이 두 가지 장점을 모두 취할 수 있는가?** 핵심은 HTML 스트리밍입니다. 정적 셸은 CDN에서 즉시 서빙되어 TTFB가 SSG와 동일합니다. 동적 부분은 같은 HTTP 응답 내에서 스트리밍되므로 추가 네트워크 요청이 필요 없습니다. Suspense 폴백이 이미 올바른 크기로 렌더링되어 있으므로 CLS도 0입니다.

### next.config.ts에서의 PPR 설정

PPR을 프로젝트 전체 또는 특정 페이지에 적용하는 방법입니다:

```typescript
// next.config.ts
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    // 프로젝트 전체에 PPR 활성화
    ppr: true,
    // 또는 점진적 도입을 위해 'incremental'
    // ppr: 'incremental',
  },
}

export default nextConfig
```

`ppr: 'incremental'`을 선택하면 각 페이지/레이아웃에서 개별적으로 opt-in할 수 있습니다:

```tsx
// 특정 페이지에서만 PPR 활성화
export const experimental_ppr = true

export default function Page() {
  // ...
}
```

## Server Actions + PPR: 시너지 효과

### 실전 패턴: 이커머스 장바구니

Server Actions와 PPR을 결합하면 진정한 시너지가 발생합니다. 장바구니 기능을 예로 들어보겠습니다.

```tsx
// app/actions/cart.ts
'use server'

import { revalidateTag } from 'next/cache'
import { cookies } from 'next/headers'

export async function addToCart(productId: string, quantity: number) {
  const cookieStore = await cookies()
  const sessionId = cookieStore.get('session-id')?.value

  if (!sessionId) {
    throw new Error('Session not found')
  }

  await db.cartItems.upsert({
    where: {
      sessionId_productId: { sessionId, productId },
    },
    update: {
      quantity: { increment: quantity },
    },
    create: {
      sessionId,
      productId,
      quantity,
    },
  })

  // 장바구니 관련 캐시만 선택적으로 무효화
  revalidateTag('cart')
  revalidateTag(`cart-${sessionId}`)
}

export async function removeFromCart(itemId: string) {
  await db.cartItems.delete({ where: { id: itemId } })
  revalidateTag('cart')
}

export async function updateQuantity(itemId: string, quantity: number) {
  if (quantity <= 0) {
    return removeFromCart(itemId)
  }

  await db.cartItems.update({
    where: { id: itemId },
    data: { quantity },
  })

  revalidateTag('cart')
}
```

```tsx
// app/cart/page.tsx
import { Suspense } from 'react'
import { CartItems } from './CartItems'
import { CartSummary } from './CartSummary'
import { RecommendedProducts } from './RecommendedProducts'

export const experimental_ppr = true

export default function CartPage() {
  return (
    <div className="cart-page">
      {/* 정적 레이아웃 - 즉시 표시 */}
      <h1>장바구니</h1>

      <div className="cart-layout">
        {/* 동적: 사용자별 장바구니 항목 */}
        <Suspense fallback={<CartItemsSkeleton />}>
          <CartItems />
        </Suspense>

        {/* 동적: 가격 합계, 배송비 계산 */}
        <Suspense fallback={<CartSummarySkeleton />}>
          <CartSummary />
        </Suspense>
      </div>

      {/* 동적: 개인화된 추천 */}
      <Suspense fallback={<RecommendationSkeleton />}>
        <RecommendedProducts />
      </Suspense>
    </div>
  )
}
```

```tsx
// components/AddToCartButton.tsx
'use client'

import { useOptimistic, useTransition } from 'react'
import { addToCart } from '@/app/actions/cart'

export function AddToCartButton({
  productId,
  stock,
}: {
  productId: string
  stock: number
}) {
  const [isPending, startTransition] = useTransition()
  const [optimisticStock, setOptimisticStock] = useOptimistic(stock)

  function handleAddToCart() {
    startTransition(async () => {
      setOptimisticStock((prev) => prev - 1)
      await addToCart(productId, 1)
    })
  }

  const isOutOfStock = optimisticStock <= 0

  return (
    <button
      onClick={handleAddToCart}
      disabled={isPending || isOutOfStock}
      className={isOutOfStock ? 'out-of-stock' : 'add-to-cart'}
    >
      {isOutOfStock
        ? '품절'
        : isPending
          ? '담는 중...'
          : `장바구니에 담기 (재고: ${optimisticStock})`}
    </button>
  )
}
```

### 캐시 전략: revalidateTag vs revalidatePath

Server Actions에서 캐시 무효화는 성능에 직접적인 영향을 미칩니다. `revalidatePath`와 `revalidateTag`의 차이를 이해하는 것이 중요합니다.

```typescript
// ❌ 너무 넓은 무효화 - 전체 페이지의 모든 데이터 캐시가 날아감
revalidatePath('/products')

// ✅ 세밀한 무효화 - 관련된 데이터만 무효화
revalidateTag('product-pricing')
revalidateTag('product-stock')
```

```typescript
// 데이터 fetch 시 태그 지정
async function getPricing(productId: string, region: string) {
  const res = await fetch(
    `${API_BASE}/pricing/${productId}?region=${region}`,
    {
      next: {
        tags: ['product-pricing', `pricing-${productId}`],
        revalidate: 60, // 60초 캐시 + 태그 기반 온디맨드 무효화
      },
    }
  )
  return res.json()
}
```

> **왜 태그 기반 무효화가 중요한가?** PPR 환경에서 `revalidatePath`를 사용하면 정적 셸까지 다시 생성해야 합니다. 반면 `revalidateTag`는 해당 태그가 붙은 데이터만 무효화하므로, 동적 부분만 새로 렌더링됩니다. 이는 서버 리소스와 응답 시간 모두에 영향을 미칩니다.

## 고급 패턴: 에러 처리와 보안

### Server Actions의 에러 처리

Server Actions에서의 에러 처리는 API 라우트와 근본적으로 다릅니다. `throw`된 에러는 클라이언트의 가장 가까운 Error Boundary로 전파됩니다. 하지만 프로덕션에서는 더 세밀한 제어가 필요합니다.

```typescript
// lib/action-utils.ts
type ActionResult<T> =
  | { success: true; data: T }
  | { success: false; error: string; fieldErrors?: Record<string, string[]> }

export function createSafeAction<TInput, TOutput>(
  schema: z.ZodSchema<TInput>,
  handler: (validated: TInput) => Promise<TOutput>
) {
  return async (input: unknown): Promise<ActionResult<TOutput>> => {
    const parsed = schema.safeParse(input)

    if (!parsed.success) {
      return {
        success: false,
        error: 'Validation failed',
        fieldErrors: parsed.error.flatten().fieldErrors as Record<string, string[]>,
      }
    }

    try {
      const result = await handler(parsed.data)
      return { success: true, data: result }
    } catch (error) {
      // 서버 에러를 클라이언트에 그대로 노출하지 않음
      console.error('Action error:', error)
      return {
        success: false,
        error: 'An unexpected error occurred. Please try again.',
      }
    }
  }
}
```

```typescript
// app/actions/todo.ts
'use server'

import { createSafeAction } from '@/lib/action-utils'

export const createTodo = createSafeAction(
  CreateTodoSchema,
  async (data) => {
    const userId = await requireAuth() // 인증 실패 시 throw
    return db.todos.create({
      data: { ...data, userId },
    })
  }
)
```

### 보안 고려사항

Server Actions는 공개 HTTP 엔드포인트를 생성합니다. 이는 보안 관점에서 API 라우트와 동일한 주의가 필요하다는 뜻입니다.

```typescript
// middleware.ts - Server Actions에도 미들웨어가 적용됨
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  // Server Actions는 POST 요청으로 들어옴
  if (request.method === 'POST' && request.headers.get('next-action')) {
    // CSRF 보호는 Next.js가 자동으로 처리
    // 추가 보안: Rate limiting
    const ip = request.ip ?? request.headers.get('x-forwarded-for')
    if (isRateLimited(ip)) {
      return NextResponse.json(
        { error: 'Too many requests' },
        { status: 429 }
      )
    }
  }

  return NextResponse.next()
}
```

```typescript
// 항상 서버에서 인증을 재확인
'use server'

import { auth } from '@/lib/auth'

export async function deleteAccount() {
  // ⚠️ 클라이언트에서 전달된 userId를 절대 신뢰하지 않음
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  // 서버에서 확인된 userId만 사용
  await db.users.delete({ where: { id: session.user.id } })
}
```

> **보안 원칙:** Server Actions를 "서버에서 실행되는 안전한 코드"로 생각하지 마세요. 이것은 "누구나 호출할 수 있는 공개 엔드포인트"입니다. 모든 Server Action에서 인증과 권한 확인을 반드시 수행하세요. `'use server'`는 보안 경계가 아니라 실행 위치를 지정하는 것입니다.

## 실전 마이그레이션 가이드

### 기존 프로젝트에 점진적으로 도입하기

모든 것을 한 번에 바꿀 필요는 없습니다. 다음 순서로 점진적 마이그레이션을 권장합니다:

**Phase 1: 새로운 폼부터 Server Actions로**

기존 API 라우트는 그대로 두고, 새로 만드는 폼만 Server Actions로 작성합니다. 이렇게 하면 팀이 패턴에 익숙해질 시간을 벌 수 있습니다.

**Phase 2: PPR incremental 모드로 핵심 페이지 적용**

트래픽이 가장 많은 페이지부터 PPR을 적용합니다. `ppr: 'incremental'` 설정으로 페이지별로 opt-in 하세요.

**Phase 3: API 라우트를 Server Actions로 교체**

기존 API 라우트를 하나씩 Server Actions로 전환합니다. 이때 중요한 것은 외부에서 호출하는 API(모바일 앱, 서드파티)는 API 라우트로 유지해야 한다는 점입니다.

```typescript
// ✅ Server Actions: 같은 Next.js 앱 내 클라이언트 ↔ 서버
// ✅ API Routes: 외부 클라이언트(모바일 앱, 서드파티)용
// ❌ Server Actions를 외부 API로 사용하려고 하지 마세요
```

### 디버깅 팁

Server Actions 디버깅은 기존 API 디버깅과 약간 다릅니다. 유용한 팁들을 공유합니다:

```typescript
// 개발 중 Server Action 실행 추적
'use server'

export async function debuggableAction(formData: FormData) {
  const startTime = performance.now()

  console.log('[Action] Start:', {
    entries: Object.fromEntries(formData),
    timestamp: new Date().toISOString(),
  })

  try {
    const result = await actualLogic(formData)

    console.log('[Action] Success:', {
      duration: `${(performance.now() - startTime).toFixed(2)}ms`,
      result: JSON.stringify(result).slice(0, 200),
    })

    return result
  } catch (error) {
    console.error('[Action] Error:', {
      duration: `${(performance.now() - startTime).toFixed(2)}ms`,
      error: error instanceof Error ? error.message : 'Unknown',
    })
    throw error
  }
}
```

## 결론: 웹 개발의 새로운 기본값

Next.js 15의 Server Actions와 Partial Prerendering은 단순한 기능 추가가 아닙니다. 이것은 웹 애플리케이션을 구축하는 방식에 대한 패러다임 전환입니다. API 라우트라는 인위적 경계를 Server Actions가 제거하고, SSR과 SSG라는 거짓된 이분법을 PPR이 해소합니다.

실제 프로덕션에서 이 두 기능을 적용하면, TTFB는 SSG 수준으로 빠르면서도 동적 콘텐츠가 매끄럽게 스트리밍되고, 데이터 변경은 타입 안전하게 처리되며, Progressive Enhancement까지 무료로 따라옵니다. 벤치마크 수치도 중요하지만, 더 중요한 것은 개발자 경험의 개선입니다. 더 적은 코드로, 더 적은 파일에서, 더 안전하게, 더 빠른 앱을 만들 수 있게 되었습니다.

물론 모든 기술이 그렇듯 만능은 아닙니다. Server Actions는 같은 Next.js 앱 내의 클라이언트-서버 통신에 최적화되어 있으며, 외부 API를 대체할 수는 없습니다. PPR은 아직 실험적 기능이고, 모든 호스팅 환경에서 최적으로 동작하지는 않습니다. 하지만 방향성은 분명합니다: 서버와 클라이언트의 경계는 점점 더 투명해지고, 개발자는 "어디서 실행될 것인가" 대신 "무엇을 만들 것인가"에 집중할 수 있게 될 것입니다.

지금 당장 `ppr: 'incremental'`을 켜고, 다음 폼은 Server Action으로 만들어 보세요. 돌아가고 싶지 않게 될 겁니다.
