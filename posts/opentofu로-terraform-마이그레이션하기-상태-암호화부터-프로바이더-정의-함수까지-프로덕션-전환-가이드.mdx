---
title: 'OpenTofu로 Terraform 마이그레이션하기: 상태 암호화부터 프로바이더 정의 함수까지 프로덕션 전환 가이드'
excerpt: 'HashiCorp의 라이선스 변경 이후 주목받는 OpenTofu로의 마이그레이션 전략을 상태 암호화, 프로바이더 정의 함수, CI/CD 파이프라인 전환까지 실전 코드와 함께 단계별로 안내합니다.'
date: '2026-02-19'
category: 'DEVOPS'
tags: ['OpenTofu', 'Terraform', 'Infrastructure as Code', 'DevOps', 'Migration']
featured: false
---

# OpenTofu로 Terraform 마이그레이션하기: 상태 암호화부터 프로바이더 정의 함수까지 프로덕션 전환 가이드

## 들어가며

2023년 8월, HashiCorp는 Terraform을 포함한 자사 제품의 라이선스를 Mozilla Public License(MPL) 2.0에서 Business Source License(BSL) 1.1로 변경한다고 발표했습니다. 이 결정은 인프라스트럭처 업계 전체에 큰 파장을 일으켰고, 그 결과 Linux Foundation 산하의 오픈소스 포크인 OpenTofu가 탄생했습니다. 2024년 1월 정식 출시 이후, OpenTofu는 단순한 포크를 넘어 독자적인 기능을 빠르게 추가하며 독립적인 생태계를 구축하고 있습니다.

2026년 현재, OpenTofu는 1.9 버전까지 릴리스되었으며 상태 파일 암호화, 프로바이더 정의 함수(provider-defined functions), 선언적 removed 블록, 루프 가능한 import 블록 등 Terraform에는 없는 기능들을 포함하고 있습니다. 특히 상태 암호화 기능은 보안 컴플라이언스가 중요한 기업 환경에서 OpenTofu 전환의 가장 큰 동기가 되고 있습니다. IBM의 HashiCorp 인수(2024년 완료) 이후 Terraform의 방향성에 대한 불확실성도 마이그레이션을 고려하는 팀에게 추가적인 동기를 부여하고 있습니다.

이 글에서는 실제 프로덕션 환경에서 Terraform을 OpenTofu로 마이그레이션하는 전체 과정을 다룹니다. 단순한 바이너리 교체를 넘어, 상태 암호화 설정, 프로바이더 정의 함수 활용, CI/CD 파이프라인 전환, 그리고 팀 전체의 워크플로우 마이그레이션까지 실전 코드와 함께 단계별로 안내합니다. 이미 Terraform을 사용 중인 팀이 최소한의 리스크로 OpenTofu로 전환할 수 있도록 검증된 패턴과 주의사항을 공유하겠습니다.

## OpenTofu vs Terraform: 2026년 현재 기능 비교

### 핵심 차이점 이해하기

OpenTofu가 Terraform 1.5.x에서 포크된 이후, 양쪽 모두 독자적인 기능 개발을 이어왔습니다. 마이그레이션을 결정하기 전에 현재 기능 차이를 명확히 이해하는 것이 중요합니다. OpenTofu는 Terraform과의 호환성을 유지하면서도 커뮤니티가 오랫동안 요청해 온 기능들을 선제적으로 구현하는 전략을 취하고 있습니다.

가장 큰 차별점은 **상태 파일 암호화**입니다. Terraform에서는 상태 파일이 평문으로 저장되어 민감한 정보(데이터베이스 비밀번호, API 키 등)가 노출될 위험이 있었습니다. S3 버킷의 서버 사이드 암호화에 의존해야 했고, 상태 파일을 직접 열면 모든 민감 데이터가 보였습니다. OpenTofu는 이를 네이티브 레벨에서 해결합니다.

두 번째는 **프로바이더 정의 함수**입니다. Terraform 1.8에서도 프로바이더 함수가 도입되었지만, OpenTofu는 1.7부터 이를 지원했으며 동적 프로바이더 정의 함수라는 확장 기능을 추가로 제공합니다. 이를 통해 프로바이더가 런타임에 커스텀 함수를 정의할 수 있어 더 유연한 설정이 가능합니다.

세 번째로 **선언적 removed 블록**이 있습니다. 리소스를 상태에서 제거할 때 `terraform state rm` 명령을 실행하는 대신, 코드에서 선언적으로 제거를 표현할 수 있습니다. 이는 코드 리뷰를 통한 인프라 변경 추적을 가능하게 합니다.

```hcl
# OpenTofu의 선언적 removed 블록
removed {
  from = aws_instance.legacy_server

  lifecycle {
    destroy = false  # 실제 인프라는 유지, 상태에서만 제거
  }
}
```

### 호환성 매트릭스

현재 OpenTofu 1.9는 대부분의 Terraform 프로바이더와 완벽히 호환됩니다. HashiCorp가 관리하는 공식 프로바이더(AWS, Azure, GCP)는 물론, 커뮤니티 프로바이더도 OpenTofu Registry를 통해 동일하게 사용할 수 있습니다. 다만 Terraform Cloud/Enterprise 전용 기능(Sentinel 정책, 프라이빗 레지스트리의 일부 기능)은 직접적인 호환이 되지 않으며, 이 부분은 Spacelift, env0, Scalr 같은 대안 플랫폼으로 대체해야 합니다.

```hcl
# 프로바이더 선언은 동일하게 동작
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.80"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.35"
    }
  }
  required_version = ">= 1.8.0"  # OpenTofu 버전
}
```

## Step 1: 마이그레이션 사전 준비

### 현재 인프라 감사

마이그레이션 첫 단계는 현재 Terraform 환경을 철저히 감사하는 것입니다. 모든 워크스페이스, 모듈, 프로바이더 버전을 문서화하고 잠재적인 호환성 문제를 식별해야 합니다. 이 과정을 건너뛰면 마이그레이션 중 예상치 못한 문제에 직면할 수 있습니다. 특히 사내 프라이빗 모듈 레지스트리를 사용하는 경우 추가적인 계획이 필요합니다.

다음 스크립트로 현재 환경을 분석할 수 있습니다:

```bash
#!/bin/bash
# audit-terraform.sh - Terraform 환경 감사 스크립트

echo "=== Terraform 환경 감사 보고서 ==="
echo "날짜: $(date)"
echo ""

# Terraform 버전 확인
echo "--- 현재 Terraform 버전 ---"
terraform version

# 모든 워크스페이스 목록
echo ""
echo "--- 워크스페이스 목록 ---"
terraform workspace list

# 프로바이더 잠금 파일 분석
echo ""
echo "--- 사용 중인 프로바이더 ---"
if [ -f ".terraform.lock.hcl" ]; then
  grep -E 'provider|version|constraints' .terraform.lock.hcl
else
  echo "잠금 파일이 없습니다. terraform init을 먼저 실행하세요."
fi

# 상태 파일 리소스 개수
echo ""
echo "--- 관리 중인 리소스 ---"
terraform state list 2>/dev/null | wc -l
echo "개의 리소스가 상태 파일에 있습니다."

# 사용 중인 모듈 확인
echo ""
echo "--- 사용 중인 모듈 ---"
grep -rh 'source\s*=' --include="*.tf" . | grep -v '.terraform' | sort -u

# Terraform Cloud/Enterprise 사용 여부
echo ""
echo "--- 원격 백엔드 설정 ---"
grep -rh 'backend\s' --include="*.tf" . | head -5
```

### OpenTofu 설치

OpenTofu는 다양한 방법으로 설치할 수 있습니다. 팀 전체의 일관성을 위해 버전 관리 도구를 사용하는 것을 권장합니다:

```bash
# macOS - Homebrew
brew install opentofu

# Linux - 공식 설치 스크립트
curl --proto '=https' --tlsv1.2 -fsSL \
  https://get.opentofu.org/install-opentofu.sh \
  -o install-opentofu.sh
chmod +x install-opentofu.sh
./install-opentofu.sh --install-method deb  # Debian/Ubuntu
./install-opentofu.sh --install-method rpm  # RHEL/CentOS

# 버전 확인
tofu version
# OpenTofu v1.9.0

# tenv를 사용한 버전 관리 (권장)
# Terraform과 OpenTofu 버전을 동시에 관리
brew install tenv
tenv tofu install 1.9.0
tenv tofu use 1.9.0
```

> **중요:** OpenTofu의 CLI 명령어는 `terraform` 대신 `tofu`를 사용합니다. 기존 스크립트에서 이 차이를 처리해야 합니다. 일부 팀에서는 전환 기간 동안 `alias terraform=tofu`를 설정하기도 하지만, 이는 혼란을 야기할 수 있으므로 명시적으로 변경하는 것을 권장합니다.

### 상태 파일 백업

마이그레이션 전 가장 중요한 단계는 상태 파일 백업입니다. 이 단계를 절대 건너뛰지 마세요:

```bash
#!/bin/bash
# backup-state.sh - 상태 파일 백업

BACKUP_DIR="./terraform-backup-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"

# 로컬 상태 파일 백업
if [ -f "terraform.tfstate" ]; then
  cp terraform.tfstate "$BACKUP_DIR/"
  cp terraform.tfstate.backup "$BACKUP_DIR/" 2>/dev/null
fi

# 원격 상태 파일 풀 & 백업
terraform state pull > "$BACKUP_DIR/remote-state.json"

# 백업 검증
echo "백업 리소스 수: $(jq '.resources | length' "$BACKUP_DIR/remote-state.json")"
echo "백업 크기: $(du -h "$BACKUP_DIR/remote-state.json" | cut -f1)"
echo "백업 위치: $BACKUP_DIR"

# S3에 추가 백업 (선택사항)
aws s3 cp "$BACKUP_DIR/remote-state.json" \
  "s3://my-backup-bucket/tofu-migration/$(date +%Y%m%d)/state.json"
```

## Step 2: 핵심 마이그레이션 실행

### 바이너리 교체와 초기화

OpenTofu는 Terraform과 동일한 상태 파일 형식을 사용하므로 바이너리 교체만으로 기본적인 마이그레이션이 완료됩니다. 그러나 실제 환경에서는 몇 가지 추가 작업이 필요합니다:

```bash
# 1. 기존 .terraform 디렉토리 정리
rm -rf .terraform
rm -f .terraform.lock.hcl

# 2. OpenTofu로 초기화
tofu init

# 출력 예시:
# Initializing the backend...
# Initializing provider plugins...
# - Finding hashicorp/aws versions matching "~> 5.80"...
# - Installing hashicorp/aws v5.82.2...
# OpenTofu has been successfully initialized!

# 3. 상태 검증 - 변경 사항이 없어야 합니다
tofu plan

# 이상적인 출력:
# No changes. Your infrastructure matches the configuration.
```

> **핵심 원칙:** `tofu plan` 결과가 "No changes"여야 합니다. 만약 변경 사항이 표시된다면, 마이그레이션을 중단하고 원인을 분석하세요. 대부분의 경우 프로바이더 버전 차이에서 비롯되며, `.terraform.lock.hcl`을 삭제하고 재초기화하면 해결됩니다.

### 다중 환경 순차 마이그레이션

프로덕션 환경을 한 번에 마이그레이션하는 것은 위험합니다. 다음 순서를 따르세요:

```bash
#!/bin/bash
# migrate-sequential.sh - 순차 마이그레이션 스크립트

ENVIRONMENTS=("dev" "staging" "production")

for env in "${ENVIRONMENTS[@]}"; do
  echo "=============================="
  echo "마이그레이션: $env 환경"
  echo "=============================="

  cd "environments/$env" || exit 1

  # 백업
  tofu state pull > "../../backups/${env}-pre-migration.json" 2>/dev/null || \
    terraform state pull > "../../backups/${env}-pre-migration.json"

  # 기존 캐시 정리
  rm -rf .terraform .terraform.lock.hcl

  # OpenTofu 초기화
  tofu init -input=false

  # Plan 검증
  PLAN_OUTPUT=$(tofu plan -detailed-exitcode 2>&1)
  EXIT_CODE=$?

  if [ $EXIT_CODE -eq 0 ]; then
    echo "✅ $env: 변경 사항 없음 - 마이그레이션 성공"
  elif [ $EXIT_CODE -eq 2 ]; then
    echo "⚠️  $env: 변경 사항 감지됨 - 수동 확인 필요"
    echo "$PLAN_OUTPUT" > "../../logs/${env}-plan-diff.log"
    echo "차이점이 logs/${env}-plan-diff.log에 저장되었습니다."

    if [ "$env" = "production" ]; then
      echo "❌ 프로덕션 마이그레이션 중단"
      exit 1
    fi
  else
    echo "❌ $env: Plan 실패 - 마이그레이션 중단"
    exit 1
  fi

  cd ../..
done

echo ""
echo "✅ 모든 환경 마이그레이션 완료!"
```

## Step 3: 상태 암호화 설정

### 왜 상태 암호화가 중요한가

Terraform 상태 파일에는 인프라의 전체 스냅샷이 담깁니다. 데이터베이스 비밀번호, TLS 인증서 키, IAM 사용자 자격 증명 등이 평문으로 포함될 수 있습니다. S3 버킷의 서버 사이드 암호화(SSE)만으로는 버킷 접근 권한이 있는 사람이라면 누구나 이 데이터를 읽을 수 있다는 문제가 있습니다. OpenTofu의 클라이언트 사이드 암호화는 상태 파일 자체를 암호화하여 이 문제를 근본적으로 해결합니다.

SOC 2, HIPAA, PCI-DSS 같은 보안 컴플라이언스 프레임워크에서는 민감한 데이터의 저장 시 암호화(encryption at rest)를 요구합니다. OpenTofu의 상태 암호화는 이러한 요구사항을 인프라 코드 레벨에서 충족시키는 가장 직접적인 방법입니다.

### AWS KMS를 사용한 상태 암호화

```hcl
# backend.tf - OpenTofu 상태 암호화 설정

terraform {
  # 기존 S3 백엔드 설정은 그대로 유지
  backend "s3" {
    bucket         = "my-company-tofu-state"
    key            = "production/terraform.tfstate"
    region         = "ap-northeast-2"
    dynamodb_table = "tofu-state-lock"
    encrypt        = true  # S3 SSE (기존 암호화)
  }

  # OpenTofu 전용: 클라이언트 사이드 상태 암호화
  encryption {
    # AWS KMS 키 소스 설정
    key_provider "aws_kms" "production" {
      kms_key_id = "arn:aws:kms:ap-northeast-2:123456789012:key/mrk-abc123"
      region     = "ap-northeast-2"
      key_spec   = "AES_256"
    }

    # AES-GCM 암호화 방법 설정
    method "aes_gcm" "primary" {
      keys = key_provider.aws_kms.production
    }

    # 상태 파일에 암호화 적용
    state {
      method   = method.aes_gcm.primary

      # 기존 평문 상태에서 마이그레이션
      # 첫 적용 후 이 블록은 제거 가능
      fallback {}
    }

    # Plan 파일에도 암호화 적용
    plan {
      method   = method.aes_gcm.primary

      fallback {}
    }
  }
}
```

### 암호화 마이그레이션 실행

```bash
# 1. 암호화 설정 추가 후 초기화
tofu init

# 2. Plan 실행 - 이 시점에서 fallback이 평문 상태를 읽습니다
tofu plan
# No changes. (상태 읽기는 fallback으로, 쓰기는 암호화로)

# 3. Apply 실행 - 상태가 암호화되어 저장됩니다
tofu apply

# 4. 암호화 확인 - 상태 파일이 암호화되었는지 검증
aws s3 cp s3://my-company-tofu-state/production/terraform.tfstate - | head -c 100
# 바이너리 데이터가 출력되면 암호화 성공

# 5. fallback 블록 제거 (암호화 마이그레이션 완료 후)
# state { method = method.aes_gcm.primary } 만 남기세요
```

### PBKDF2 패스프레이즈 기반 암호화 (KMS 없는 환경)

AWS KMS를 사용할 수 없는 환경에서는 패스프레이즈 기반 암호화를 사용할 수 있습니다:

```hcl
terraform {
  encryption {
    key_provider "pbkdf2" "passphrase" {
      passphrase = var.state_encryption_passphrase
    }

    method "aes_gcm" "primary" {
      keys = key_provider.pbkdf2.passphrase
    }

    state {
      method = method.aes_gcm.primary
    }

    plan {
      method = method.aes_gcm.primary
    }
  }
}

variable "state_encryption_passphrase" {
  type        = string
  sensitive   = true
  description = "상태 파일 암호화 패스프레이즈"
}
```

```bash
# 환경 변수로 패스프레이즈 전달
export TF_VAR_state_encryption_passphrase="$(vault kv get -field=passphrase secret/tofu/encryption)"
tofu plan
```

## Step 4: 프로바이더 정의 함수 활용

### 동적 함수로 인프라 코드 개선

OpenTofu의 프로바이더 정의 함수는 HCL의 내장 함수만으로는 처리하기 어려웠던 복잡한 변환 로직을 프로바이더 레벨에서 지원합니다. 이를 통해 외부 데이터 소스나 복잡한 locals 블록 없이도 깔끔한 코드를 작성할 수 있습니다. 실무에서 가장 유용한 패턴들을 살펴보겠습니다.

```hcl
# AWS 프로바이더의 ARN 파싱 함수 활용
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.80"
    }
  }
}

locals {
  # 프로바이더 정의 함수로 ARN 파싱
  # 기존: 정규식이나 split으로 복잡하게 파싱
  # 신규: 프로바이더가 제공하는 네이티브 함수 사용
  parsed_arn = provider::aws::arn_parse(
    "arn:aws:iam::123456789012:role/my-role"
  )

  account_id  = local.parsed_arn.account_id   # "123456789012"
  service     = local.parsed_arn.service       # "iam"
  resource    = local.parsed_arn.resource      # "role/my-role"
}

# 실전 활용: 크로스 계정 리소스 참조
data "aws_iam_roles" "all" {}

locals {
  # 모든 역할의 ARN을 파싱하여 서비스별로 그룹화
  role_details = {
    for role_arn in data.aws_iam_roles.all.arns :
    role_arn => provider::aws::arn_parse(role_arn)
  }

  # 특정 패턴의 역할만 필터링
  admin_roles = {
    for arn, detail in local.role_details :
    arn => detail
    if can(regex(".*Admin.*", detail.resource))
  }
}
```

### 커스텀 유효성 검증에 활용

```hcl
# CIDR 블록 유효성 검증과 계산
variable "vpc_cidr" {
  type        = string
  description = "VPC CIDR 블록"

  validation {
    # 프로바이더 함수로 CIDR 유효성 검증
    condition = can(
      provider::aws::arn_parse(
        "arn:aws:ec2:ap-northeast-2:000000000000:vpc/vpc-dummy"
      )
    )
    error_message = "올바른 CIDR 형식이어야 합니다."
  }
}

# 네트워크 서브넷 자동 계산
locals {
  # cidrsubnets 내장 함수와 프로바이더 함수 조합
  subnet_cidrs = cidrsubnets(var.vpc_cidr, 4, 4, 4, 8, 8, 8)

  subnets = {
    public_a  = local.subnet_cidrs[0]
    public_b  = local.subnet_cidrs[1]
    public_c  = local.subnet_cidrs[2]
    private_a = local.subnet_cidrs[3]
    private_b = local.subnet_cidrs[4]
    private_c = local.subnet_cidrs[5]
  }
}

resource "aws_subnet" "this" {
  for_each = local.subnets

  vpc_id            = aws_vpc.main.id
  cidr_block        = each.value
  availability_zone = "${var.region}${substr(each.key, -1, 1)}"

  tags = {
    Name = "${var.project}-${each.key}"
    Tier = startswith(each.key, "public") ? "public" : "private"
  }
}
```

## Step 5: CI/CD 파이프라인 전환

### GitHub Actions 워크플로우

기존 Terraform CI/CD 파이프라인을 OpenTofu로 전환하는 것은 비교적 간단하지만, 몇 가지 중요한 차이점이 있습니다. setup-terraform 대신 setup-opentofu를 사용하고, 상태 암호화를 위한 KMS 권한을 추가해야 합니다. 또한 Plan 결과를 PR 코멘트로 표시하는 방식도 약간 다릅니다.

```yaml
# .github/workflows/tofu-plan.yml
name: OpenTofu Plan

on:
  pull_request:
    paths:
      - 'infrastructure/**'

permissions:
  id-token: write    # OIDC 인증용
  contents: read
  pull-requests: write  # PR 코멘트용

env:
  TF_IN_AUTOMATION: "true"
  TOFU_VERSION: "1.9.0"

jobs:
  plan:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [dev, staging, production]
    defaults:
      run:
        working-directory: infrastructure/environments/${{ matrix.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-tofu-role
          aws-region: ap-northeast-2

      - name: OpenTofu Init
        id: init
        run: tofu init -input=false

      - name: OpenTofu Validate
        id: validate
        run: tofu validate -no-color

      - name: OpenTofu Plan
        id: plan
        run: |
          tofu plan -no-color -input=false -out=tfplan \
            -detailed-exitcode 2>&1 | tee plan-output.txt
        continue-on-error: true

      - name: Post Plan to PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync(
              'infrastructure/environments/${{ matrix.environment }}/plan-output.txt',
              'utf8'
            );

            const truncated = plan.length > 60000
              ? plan.substring(0, 60000) + '\n\n... (truncated)'
              : plan;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `### 📋 OpenTofu Plan - \`${{ matrix.environment }}\`

            \`\`\`hcl
            ${truncated}
            \`\`\`

            **Exit Code:** ${{ steps.plan.outcome }}`
            });
```

```yaml
# .github/workflows/tofu-apply.yml
name: OpenTofu Apply

on:
  push:
    branches: [main]
    paths:
      - 'infrastructure/**'

permissions:
  id-token: write
  contents: read

jobs:
  apply:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1  # 순차 실행
      matrix:
        environment: [dev, staging, production]
    environment: ${{ matrix.environment }}  # 환경별 승인 게이트

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: "1.9.0"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-tofu-role
          aws-region: ap-northeast-2

      - name: Init & Apply
        working-directory: infrastructure/environments/${{ matrix.environment }}
        run: |
          tofu init -input=false
          tofu apply -auto-approve -input=false
```

### GitLab CI/CD 전환

```yaml
# .gitlab-ci.yml
stages:
  - validate
  - plan
  - apply

variables:
  TOFU_VERSION: "1.9.0"
  TF_IN_AUTOMATION: "true"

.tofu-base:
  image: ghcr.io/opentofu/opentofu:${TOFU_VERSION}
  before_script:
    - tofu init -input=false
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .terraform/

validate:
  extends: .tofu-base
  stage: validate
  script:
    - tofu fmt -check -recursive
    - tofu validate

plan:
  extends: .tofu-base
  stage: plan
  script:
    - tofu plan -out=plan.cache -input=false
  artifacts:
    paths:
      - plan.cache
    expire_in: 1 week
  rules:
    - if: $CI_MERGE_REQUEST_IID

apply:
  extends: .tofu-base
  stage: apply
  script:
    - tofu apply -auto-approve -input=false
  environment:
    name: production
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual  # 수동 승인 필요
```

## Step 6: 모듈 레지스트리 마이그레이션

### Terraform Registry에서 OpenTofu Registry로

OpenTofu는 자체 모듈 레지스트리(registry.opentofu.org)를 운영합니다. 대부분의 공개 모듈은 양쪽 레지스트리에서 모두 사용 가능하지만, 프라이빗 모듈을 사용하는 경우 마이그레이션이 필요합니다. OpenTofu는 GitHub, GitLab, S3 등 다양한 소스에서 모듈을 직접 참조할 수 있으므로 프라이빗 레지스트리 없이도 운영이 가능합니다.

```hcl
# 공개 모듈 - 소스 변경 불필요
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.16.0"

  name = var.project_name
  cidr = var.vpc_cidr

  azs             = ["ap-northeast-2a", "ap-northeast-2b", "ap-northeast-2c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]

  enable_nat_gateway = true
  single_nat_gateway = true
}

# 프라이빗 모듈 - Git 직접 참조로 전환
module "internal_service" {
  # 기존: Terraform Cloud 프라이빗 레지스트리
  # source  = "app.terraform.io/my-org/service/aws"

  # 신규: Git 직접 참조
  source = "git::https://github.com/my-org/terraform-aws-service.git?ref=v2.1.0"

  service_name = "api-gateway"
  environment  = var.environment
}

# S3에서 모듈 참조 (에어갭 환경)
module "compliance" {
  source = "s3::https://s3-ap-northeast-2.amazonaws.com/my-modules/compliance/v1.0.0.zip"
}
```

## Step 7: 팀 교육과 점진적 전환

### 전환 전략

대규모 팀에서는 빅뱅 마이그레이션 대신 점진적 전환을 추천합니다. 새 프로젝트는 OpenTofu로 시작하고, 기존 프로젝트는 자연스러운 업데이트 시점에 마이그레이션합니다. 이 전략은 팀의 학습 곡선을 완만하게 하고, 문제 발생 시 영향 범위를 최소화합니다.

개발자 워크스테이션에서는 tenv 같은 도구를 사용하여 Terraform과 OpenTofu를 동시에 유지할 수 있습니다. 디렉토리별 `.opentofu-version` 또는 `.terraform-version` 파일로 자동 전환되므로 개발자가 명시적으로 버전을 선택할 필요가 없습니다.

```bash
# .opentofu-version 파일로 프로젝트별 버전 관리
echo "1.9.0" > .opentofu-version

# tenv가 자동으로 올바른 바이너리 선택
cd legacy-project/    # .terraform-version → terraform 사용
cd new-project/       # .opentofu-version → tofu 사용
```

### Makefile 래퍼

팀 전체의 일관된 워크플로우를 위한 Makefile:

```makefile
# Makefile - OpenTofu/Terraform 호환 워크플로우

# 자동 감지: .opentofu-version이 있으면 tofu, 없으면 terraform
TOFU := $(shell which tofu 2>/dev/null)
TF := $(if $(TOFU),tofu,terraform)

.PHONY: init plan apply destroy fmt validate lint

init:
	$(TF) init -input=false -upgrade

plan:
	$(TF) plan -out=.planfile -input=false

apply:
	$(TF) apply .planfile

destroy:
	$(TF) destroy -auto-approve

fmt:
	$(TF) fmt -recursive -check

validate: init
	$(TF) validate

lint: fmt validate
	@echo "✅ 린트 통과"

# 상태 관리
state-list:
	$(TF) state list

state-backup:
	$(TF) state pull > state-backup-$$(date +%Y%m%d%H%M%S).json

# 암호화 상태 확인 (OpenTofu 전용)
encryption-status:
	@if [ "$(TF)" = "tofu" ]; then \
		echo "OpenTofu 상태 암호화가 활성화되어 있습니다."; \
		$(TF) state pull | head -c 50 | file -; \
	else \
		echo "Terraform은 네이티브 상태 암호화를 지원하지 않습니다."; \
	fi
```

## 트러블슈팅 가이드

마이그레이션 과정에서 가장 자주 발생하는 문제들과 해결 방법을 정리했습니다. 커뮤니티에서 수집한 실전 사례를 기반으로 합니다.

**프로바이더 해시 불일치:** `.terraform.lock.hcl`의 프로바이더 해시가 OpenTofu와 Terraform 사이에서 일치하지 않을 수 있습니다. 이는 각 도구가 다른 빌드 환경에서 프로바이더를 다운로드하기 때문입니다.

```bash
# 해결: 잠금 파일을 재생성
rm .terraform.lock.hcl
tofu init -upgrade
# 새로운 잠금 파일이 OpenTofu에 맞게 생성됩니다
```

**상태 잠금 충돌:** DynamoDB 기반 상태 잠금은 동일하게 동작하지만, Terraform과 OpenTofu가 동시에 같은 상태에 접근하면 잠금 충돌이 발생할 수 있습니다.

```bash
# 잠금 강제 해제 (주의해서 사용)
tofu force-unlock <LOCK_ID>
```

**모듈 소스 호환성:** `registry.terraform.io`에서 호스팅되는 모듈은 OpenTofu에서 자동으로 `registry.opentofu.org`로 리다이렉트됩니다. 하지만 일부 프라이빗 레지스트리는 수동 설정이 필요합니다.

```hcl
# ~/.tofurc - OpenTofu 설정 파일
provider_installation {
  network_mirror {
    url = "https://registry.opentofu.org"
  }
  direct {
    exclude = []
  }
}
```

## 마치며

OpenTofu로의 마이그레이션은 단순한 도구 교체가 아닌 인프라 관리 철학의 전환입니다. 오픈소스 거버넌스, 보안 강화(상태 암호화), 그리고 커뮤니티 주도 발전이라는 가치를 선택하는 것입니다. 기술적으로 마이그레이션 자체는 높은 호환성 덕분에 상대적으로 쉽지만, 팀 전체의 워크플로우와 CI/CD 파이프라인 전환에는 계획과 준비가 필요합니다.

이 글에서 다룬 단계별 접근법—환경 감사, 순차 마이그레이션, 상태 암호화, CI/CD 전환, 팀 교육—을 따르면 프로덕션 인프라를 안전하게 OpenTofu로 이전할 수 있습니다. 특히 상태 암호화 기능은 보안 감사를 앞둔 팀에게 즉각적인 가치를 제공하며, 프로바이더 정의 함수는 인프라 코드의 표현력을 한 단계 높여줍니다. OpenTofu 생태계가 빠르게 성숙하고 있는 만큼, 지금이 마이그레이션을 시작하기 좋은 시점입니다.
