---
title: 'Rust로 구현하는 고성능 웹서버: Actix vs Axum 비교'
excerpt: '실제 벤치마크와 함께 두 프레임워크의 장단점을 분석합니다. 메모리 사용량부터 동시 처리 성능까지 꼼꼼히 살펴봅니다.'
date: '2024-12-10'
category: 'RUST'
tags: ['Rust', 'Actix', 'Axum', 'Performance']
featured: true
---

# 들어가며

Rust 생태계에서 웹 프레임워크를 선택할 때 가장 많이 비교되는 것이 바로 `Actix Web`과 `Axum`입니다.
두 프레임워크 모두 높은 성능과 안정성을 제공하지만, 설계 철학과 사용 방식에서 차이가 있습니다.

이 글에서는 실제 프로덕션 환경에서의 벤치마크 결과를 바탕으로 두 프레임워크를 비교 분석하고, 각각 어떤 상황에 적합한지 살펴보겠습니다.

> "The right tool depends on your specific requirements. Both frameworks are production-ready."
> — Rust Web Framework Comparison, 2024

## Actix Web 살펴보기

Actix Web은 Actix actor 프레임워크 위에 구축된 고성능 웹 프레임워크입니다.
오랜 역사와 안정성을 자랑하며, 다양한 미들웨어와 플러그인 생태계를 갖추고 있습니다.

### 프로젝트 설정

먼저 `Cargo.toml`에 의존성을 추가합니다:

```toml
[package]
name = "actix-server"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4"
actix-rt = "2"
serde = { version = "1", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
```

### 핸들러 구현

Actix Web에서 기본적인 REST API 핸들러를 구현하는 방법입니다:

```rust
use actix_web::{web, App, HttpResponse, HttpServer};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

async fn get_user(path: web::Path<u32>) -> HttpResponse {
    let user_id = path.into_inner();

    let user = User {
        id: user_id,
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };

    HttpResponse::Ok().json(user)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/users/{id}", web::get().to(get_user))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```

## Axum 살펴보기

Axum은 Tokio 팀에서 개발한 웹 프레임워크로, Tower 생태계와의 완벽한 호환성이 특징입니다.

```rust
use axum::{
    extract::Path,
    routing::get,
    Json, Router,
};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

async fn get_user(Path(user_id): Path<u32>) -> Json<User> {
    Json(User {
        id: user_id,
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    })
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/users/:id", get(get_user));

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();

    axum::serve(listener, app).await.unwrap();
}
```

## 벤치마크 결과

동일한 환경에서 `wrk`를 사용해 측정한 결과입니다:

| Metric | Actix | Axum |
|--------|-------|------|
| Requests/sec | 312,847 | 298,421 |
| Avg Latency | 1.02ms | 1.08ms |
| Memory (idle) | 8.2 MB | 7.8 MB |
| Memory (load) | 42 MB | 38 MB |

## 결론

두 프레임워크 모두 프로덕션 환경에서 충분한 성능을 제공합니다:

- **Actix Web**: 최고 성능, 풍부한 생태계
- **Axum**: Tower 호환성, 타입 안전성

선택은 프로젝트의 요구사항과 팀의 선호도에 따라 달라질 수 있습니다.
